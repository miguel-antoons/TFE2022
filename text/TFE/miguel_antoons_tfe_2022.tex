\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{lingmacros}
\usepackage{tree-dvips}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage[bottom]{footmisc}
\usepackage[french]{babel}
\usepackage{hyperref}
\def\UrlBreaks{\do\/\do-}
\usepackage{listings}
\graphicspath{ {./images/} }

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}

\newenvironment{remerciements}
  {
   \thispagestyle{empty}% no header and footer
   \vspace*{\stretch{1}}% some space at the top
   \itshape             % the text is in italics
  }
  {\par % end the paragraph
   \vspace{\stretch{3}} % space at bottom is three times that at the top
   \clearpage           % finish off the page
  }

\title{Monitoring des données BRAMS et détection automatique des échos de météore}
\author{Miguel Antoons}

\begin{document}

\begin{titlepage}
    \begin{center}
        \includegraphics[]{logo_ephec.png}\\
        \Large
        \textbf{Technologie de l'Informatique}\\
        \large
        Avenue du Ciseau 15\\
        1348 Ottignies
    \end{center}

    \vspace*{\stretch{1.0}}

    \begin{center}
        \line(1,0){350}\\
        \LARGE\textbf{Monitoring des données BRAMS et détection automatique des échos de météore}\\
        \line(1,0){350}\\
        \vspace{0.5cm}
        \LARGE\textit{Miguel Antoons}\\
        \vspace{0.5cm}
        \Large\textbf{Rapporteur}\\
        \Large\textit{Monsieur Arnaud Dewulf}
    \end{center}

    \vspace{0.14cm}

    \begin{center}
        \includegraphics[scale=0.225]{page_garde.png}\\
        \vspace{0.14cm}
        \textit{2021-2022}
    \end{center}



    \vspace*{\stretch{2.0}}
\end{titlepage}

\section*{Remerciements}
\begin{remerciements}
    Je tiens tout d'abord à remercier toutes les personnes qui m'ont aidé à réaliser ce projet de fin d'études.\\
    \par
    En commençant par mon professeur rapporteur, à qui j'ai pu poser mes questions en cas de besoin et qui s'est assuré que tout se passe bien tout au long du projet.\\
    \par
    Ensuite, je voudrai remercier Mr Hervé Lamy pour avoir proposé ce sujet de fin d'études, mais également pour m'avoir expliqué, de façon claire et précise, toutes les notions qui nécessitaient des explications.\\
    \par
    Je tiens également à remercier Mrs Antoine Calegaro et Michel Anciaux, qui m'ont guidé quand c'était nécessaire et qui m'ont conseillé durant le projet de fin d'études.\\
    \par
    Enfin, je voudrais exprimer ma reconnaissance envers toutes les personnes qui m'ont conseillé sur, et ont relu ce rapport de projet de fin d'études.
\end{remerciements}

\newpage

\tableofcontents

\newpage

\section{Introduction}

Chaque jour, des milliers d'objets passent tout près de l'atmosphère terrestre.
Parmi ces objets, on retrouve les météoroïdes : un corps pierreux ou métallique d'une largeur pouvant varier de quelques millimètres à un mètre.
Un météoroïde, une fois rentré dans l'atmosphère, devient un météore et peut créer un phénomène lumineux connu sous le nom de "Étoile filante".
Contrairement à ce que l'on peut penser, un météoroïde qui entre dans l'atmosphère terrestre est un événement qui se produit des milliers de fois par jour.
\\
\\
L'étude de ces météores permet de retrouver différentes informations telles que la masse ou encore la trajectoire de ceux-ci.
Ce travail de fin d'étude a pour objectif de faciliter l'étude de météores.
Il fera ceci en permettant une visualisation facile de la qualité des données étudiées et en automatisant une partie de la détection des météores.
Mais, afin de pouvoir les étudier, il est nécessaire de les détecter avant.
Actuellement, différentes techniques existent pour détecter des météores dans l'atmosphère.
\\
\\
L'une d'entre elles est la détection à l'aide de caméras.
Ceci a l'avantage de directement voir la trajectoire du météore et facilite donc l'étude.
Cependant, elle a un grand défaut : lorsque le ciel est nuageux ou qu'il fait jour la technique est moins efficace.
De plus, lorsqu'un petit météoroïde entre dans l'atmosphère, elle ne produit pas assez de lumière pour pouvoir être détecté par une caméra.
C'est alors qu'une autre technique, celle par détection à l'aide d'ondes radio devient intéressante.
\\
\\
Ce travail de fin d'études consistera à l'automatisation de deux étapes du traitement des données produites par cette dernière technique.
%? Personal objectives?

\newpage

\section{Détection des météores par ondes radios}

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.37]{ForwardScatter_principle.png}
        \caption{Détection d'un météore à l'aide d'ondes radios.}
        \label{fig:forward_scatt}
    \end{center}
\end{figure}

Quand un météoroïde entre dans la partie haute de l'atmosphère (approximativement à 80 - 120 km de la surface terrestre) il laisse derrière lui une trainée ionisée.
Cette trainée à la propriété de réfléchir les ondes radio.
On peut donc détecter un météore à l'aide de sa trainée ionisée.
\\
\\
Afin d'exploiter cette réflexion, il nous faut un émetteur dont le signal radio est réfléchi à l'aide de la trainée d'un météore et est ensuite enregistré par un récepteur.
Cette procédure est illustrée à la figure \ref{fig:forward_scatt}, où la flèche jaune représente la trainée ionisée produite par le météore.
Le signal reçu par l'émetteur est alors appelé un écho de météore.
Un écho de météore peut durer entre une et 10 secondes, selon la durée d'existence de la trainée ionisée.
\\
\\
Une caractéristique importante de cette technique de détection est la réflexion spéculaire.
Ceci veut dire que la trainée ionisée du météore agit comme un miroir sur lequel la réflexion se produit uniquement à un point précis, appelé le point de réflexion spéculaire.
Le point de réflexion spéculaire dépend de la position de l'émetteur, la position du récepteur et la trajectoire du météore.
La conséquence est que les données reçues par un récepteur particulier sont relatives qu'à une partie précise de la trainée.
\\
\\
De plus, deux récepteurs, situés à des endroits différents, enregistreront un écho de météore à des instants différents puisque leurs points de réflexion spéculaire sont situés à des endroits différents sur la trajectoire.
Ceci est illustré à la figure \ref{fig:specular_reflex} où le point de réflexion P0 entre le transmetteur Tx et le récepteur Rx0 est situé à un endroit différent que le point de réflexion P1 entre le transmetteur et le récepteur Rx1.

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=1]{scema_reflexion_speculaire.png}
        \caption{Le point de réflexion spéculaire est différent pour chaque station réceptrice.}
        \label{fig:specular_reflex}
    \end{center}
\end{figure}

%! below part must not be here
% Pour exploiter le phénomène de la réflexion spéculaire et réussir à détecter les météores à l'aide d'ondes radios, le réseau BRAMS fonctionne de la façon suivante :
% \begin{enumerate}
%     \item Un émetteur, situé à Dourbes, transmet de façon continue un signal à une fréquence de 49.97 MHz.
%           Ce signal est émis en direction du ciel et peut être réfléchi sur des trainées ionisées dans le sillage des météores.
%     \item Lorsque le signal est réfléchi, il peut être détecté par une ou plusieurs stations réceptrices faisant partie du réseau BRAMS.
%           Un signal calibreur est alors additionné au signal venant du ciel.
%           Ce signal est injecté à 49.9705 MHz, c'est-à-dire 500 Hz plus haut que le signal direct.
%           Il dispose d'une amplitude fixe et sert de référence d'amplitude pour le reste du signal.
%           La station réceptrice décale ensuite le signal direct de 49.97 MHz vers une fréquence de 1 kHz.
%     \item Ensuite, la station réceptrice enregistre l'ensemble du signal dans un fichier audio de type WAV.
%           Le signal est échantillonné à une fréquence de 5512,5 Hz pour les stations ICOM et 6048 Hz pour les stations RSP2.
%           Si tout se passe bien, un fichier est généré toutes les cinq minutes et chaque fichier devrait commencer et terminer à un temps prédéfini (par exemple : 16 h 00 à 16 h 05, 16 h 05 à 16 h 10, etc.).
%     \item Tous les fichiers générés par les stations réceptrices sont envoyés à intervalle régulier aux serveurs utilisés pour le projet BRAMS par internet.
%     \item Une fois sur le serveur, les fichiers WAV sont archivés, manipulés et étudiés par les scientifiques du projet BRAMS afin d'en extraire les informations utiles.
% \end{enumerate}

\newpage

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.5]{station_map.png}
        \caption{Carte montrant l'emplacement de l'émetteur et des réceptrices.}
        \label{fig:station_map}
    \end{center}
\end{figure}

\section{Le projet BRAMS}

Lancé en 2010 par Monsieur Hervé Lamy à l'Institut Royal d'Aéronomie Spatiale de Belgique, le projet BRAMS (Belgian RAdio Meteor Stations) a pour but de détecter et d'étudier les météores.
Il dispose pour ceci d'un réseau d'un émetteur et de quarante-deux récepteurs situés dans la Belgique et dans les pays avoisinants qui utilise la détection des météores par ondes radios.
Dans cette section, ce réseau et son fonctionnement seront expliqués.

\subsection{L'Émetteur}

Le réseau BRAMS dispose donc d'un émetteur unique situé à Dourbes, dans le sud de la Belgique.
Sa location peut être visualisé sur la figure \ref{fig:station_map} où l'émetteur est représenté par un triangle bleue.
Cet émetteur transmet de façon continue un signal à la fréquence 49.970 MHz et d'une puissance d'approximativement 120 W.
Ce signal sera réfléchi sur d'éventuelles trainées de météores et pourra être détecté par des récepteurs.

\subsection{Les Stations de Réception}
%! below part needs to be restructured
Afin d'accomplir ce but, le projet BRAMS dispose d'un réseau de stations nommé le réseau BRAMS.
Ce réseau est composé d'un ensemble de quarante-deux stations émettrices, situées en Belgique ou dans les pays avoisinants, et d'un émetteur dédié situé à Dourbes, dans le sud de la Belgique.\\
\\

\subsubsection{Les Stations V1}

\subsubsection{Les Stations V2}
Il existe 2 types de station de réception :
% ! the part below should be divided in 2 subtitles and should also be developped more
\begin{itemize}
    \item Il y a d'abord les stations avec des récepteurs Icom IC-R75, que j'apellerai les récepteurs ICOM dans ce document.
          Ce sont les premières stations réceptrices mises en service pour le réseau BRAMS.
          Actuellement, ces stations ne sont plus utilisées suite à l'arrêt de la commercialisation du récepteur Icom IC-R75.
          De plus, une variation de température pouvait causer une légère déstabilisation en fréquence.
    \item C'est alors que les stations utilisant le récepteur RSP 2 ont été développés.
          Ces stations n'éliminaient pas seulement en grande partie les problèmes des anciennes stations, mais sont également plus compacts et plus faciles à installer.
          Une image des stations RSP 2 peut être trouvé à la figure 1.
\end{itemize}

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.5]{RPS2.png}
        \caption{Station RSP 2 du réseau BRAMS}
    \end{center}
\end{figure}

% \subsubsection{Le Format WAV}

% Le format de fichier WAV (Waveform Audio File) est un format destiné au stockage de signal audio développé par Microsoft et IBM.
% Il est construit conformément au RIFF (Ressource Interchange File Format) ce qui veut dire que le fichier est organisé en blocs de données, aussi nommés des "chunks" ou "data chunks".\\
% \\
% Chaque bloc de données dispose d'un ID codé sur 4 octets, qui représente souvent un mot de 4 lettres.
% Suit ensuite le champ "subChunkSize" indiquant la taille des données à venir dans le bloc de données, codé également sur 4 octets.
% Cette valeur exclut donc les champs "ID" et "subChunkSize" du bloc courant.
% Après ces 2 champs, on est libre de rajouter le nombre de champs que l'on souhaite, avec la taille en octets que l'on souhaite.\\
% \\
% Pour un fichier WAV, on retrouve typiquement 3 blocs de données.
% On retrouve premièrement le bloc "RIFF", dont le champ "ID" contient les quatre lettres "RIFF".
% Ce bloc est particulier puisque, au lieu d'avoir un champ "subChunkSize", il a un champ "ChunkSize".
% La différence est que, contrairement au champ "subChunkSize", le champ "ChunkSize" contient la taille de l'entièreté du fichier, exclu le champ "ID" et le champ "ChunkSize" même du bloc "RIFF".
% Vient ensuite le champ "format", ce champ indique le type de fichier actuel.
% Dans le cas du fichier WAV, ce dernier contient les quatre lettres "WAVE".\\
% \\
% Le deuxième bloc, nommé le bloc FMT\footnote{FMT pour format}, contenu dans un fichier WAV ordinaire contient toutes les données techniques des données.
% On y trouve notamment la fréquence d'échantillonnage, le nombre de pistes audio ou encore le nombre d'octets par secondes.\\
% \\
% Vient enfin le bloc principal du fichier : le bloc de données.
% C'est dans ce bloc que se trouvent les données audio brutes.
% La taille de ce bloc varie bien-entendu selon les caractéristiques techniques des données audio (longueur, fréquence d'échantillonnage, nombre de pistes, etc.).\\
% \\
% Une chose à noter à propos des fichiers WAV est que leur structure offre une grande flexibilité.
% En effet, elle permet non-seulement de lire et interpréter les fichiers facilement, mais également de rajouter des blocs de données personnalisés sans corrompre les autres données.\\
% \\
% La figure 2 montre la structure d'un fichier WAV ordinaire.

% \begin{figure}[t]
%     \begin{center}
%         \includegraphics[scale=0.3]{wav_structure.png}
%         \caption{Structure d'un fichier WAV ordinaire}
%     \end{center}
% \end{figure}

% \newpage

\subsection{Les Données BRAMS}

Un fichier WAV venant d'une station réceptrice contient donc le signal capté par l'antenne ensemble avec un signal calibreur.
Il est composé d'une seule piste audio, échantillonnée à une fréquence de 5512.5 Hz ou 6048 Hz.
Cette fréquence permet d'enregistrer des données dans une bande de fréquences allant jusqu'à 2756.25 Hz ou 3024 Hz (ou la moitié de la fréquence d'échantillonnage), selon le théorème de Nyquist.
Sachant que les échos de météores apparaissent typiquement dans une bande de fréquence de 100 Hz autour du signal de l'émetteur à 1000 Hz, cette bande de fréquence couvre l'ensemble des signaux utiles à l'étude des météores.\\
\\
À chaque fichier WAV est rajouté un bloc de données (data chunk) conçu pour faciliter l'étude des données.
Dans ce bloc, on retrouve quelques informations relatives à la station de réception, la station émettrice, le signal GPS\footnote{Global Positioning System} ou encore, la fréquence d'échantillonnage.
Ce bloc de données se trouve entre le bloc FMT et le bloc de données.\\
\\
Ces fichiers audio, comme montrée à la figure 4, sont très difficiles à interpréter.
Ils sont composés de bruits et de parasites sur l'entièreté de leur bande de fréquence.
Par contre, lorsque l'on calcule le spectrogramme du fichier WAV, les données deviennent beaucoup plus simples à lire.
\begin{figure}[t] % ! below image must be changed to a better one
    \begin{center}
        \includegraphics[scale=0.5]{wav_brut.png}
        \caption{Données brutes venant d'un fichier audio d'une station réceptrice.}
    \end{center}
\end{figure}
\\
\\
Un spectrogramme est une représentation différente des données contenues dans un fichier audio.
Au lieu de représenter la puissance sur l'ordonnée et le temps sur l'abscisse, un spectrogramme représente la répartition des fréquences au cours du temps.
Il contient donc trois axes :
\begin{itemize}
    \item Sur l'abscisse on retrouve toujours le temps.
    \item Sur l'ordonnée on retrouve la fréquence.
    \item Sur la cote, on retrouve la puissance. Cet axe est souvent représenté par un code couleur.
\end{itemize}

Pour générer un spectrogramme, il faut calculer un ensemble de Transformées de Fourrier.
La Transformée de Fourrier permet de représenter la répartition de puissance entre les fréquences contenues dans un signal ou une partie d'un signal temporel.
Elle produit donc se qu'on appelle le spectre du signal.
Elle se calcule sur un nombre quelconque d'échantillons qui se suivent dans un signal temporel.
Dans l'informatique, elle est souvent calculée à l'aide de la FFT\footnote{Faste Fourier transform}.
C'est un algorithme qui permet de calculer une Transformée de Fourrier plus rapidement, mais qui exige un nombre d'échantillons $2^{n}$.\\
\\
Sur la figure 5, on peut voir en rouge un signal temporel et le spectre de ce même signal en bleu.
Les signaux en mauve claire sont les signaux à une fréquence, dont le signal rouge est composé.
\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.7]{spectre.png}
        \caption{Représentation visuelle de la Transformée de Fourier.}
    \end{center}
\end{figure}
\\
\\
Dans le cas des spectrogrammes pour le projet BRAMS, les FFT contenus dans un spectrogramme sont calculés sur 16384 échantillons.
Si on suppose qu'un fichier WAV venant d'une station réceptrice dure en moyenne trois-cents secondes (ou cinq minutes), un spectrogramme est composé d'environ 101 spectres pour les stations ICOM et 111 pour les staions RSP2.
Ce nombre est obtenu avec la formule ci-dessous, où Fs est la fréquence d'échantillonnage, T la durée en secondes du signal et nfft le nombre d'échantillons utilisés pour générer un spectre.
\[\frac{Fs * T}{nfft}\]
Le spectrogramme généré aura une résolution fréquentielle, donnée par la formule \(Fs / nfft\), de 0.34 Hz pour les stations ICOM et 0.37 Hz pour les stations RSP2.
Sa résolution temporelle, donnée par la formule \(nfft / Fs\), est de 2.97 secondes pour les stations ICOM et de 2.7 secondes pour les stations RSP2.
Un exemple de spectrogramme venant d'une station de réception est affiché à la figure 6.

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.29]{spectrogramme_legend.png}
        \caption{Exemple d'un spectrogramme du projet BRAMS.}
    \end{center}
\end{figure}

\subsection{L'Archive BRAMS}

Quand les fichiers venant des stations de réception sont archivés, ils sont placés dans une structure de répertoires spécifique.
Cette structure dépend de la date de début d'enregistrement des données contenues dans le fichier.\\
\\
Dans la première couche de l'archive, on retrouve un répertoire par station BRAMS.
Chaque nom de répertoire est le code de location de la station dont elle contient les données.
Ensuite, on retrouve un nombre de répertoires, chacun contenant les fichiers d'une année spécifique.
Le nom de ces répertoires est donc l'année des données qu'elles contiennent.
Si on rentre dans le répertoire d'une année, on se retrouve dans la troisième couche de l'archive BRAMS.
Ici, les données sont encore une fois séparées selon le mois d'enregistrement du fichier.
Finalement, dans la quatrième couche de l'archive, on retrouve un répertoire par jour d'enregistrement d'un fichier.\\
\\
Dans chaque répertoire représentant un jour spécifique, on retrouve les données BRAMS organisés par heure dans des fichiers de format TAR.
Ce format permet de regrouper plusieurs fichiers dans un même fichier, qui prend alors le format TAR.
Le nom des fichiers TAR et les fichiers WAV qui se trouvent à l'intérieur des fichiers TAR suivent également une structure fixe.
Il est composé de six informations ordonnées de la manière suivante :
\begin{enumerate}
    \item Les trois lettres \textbf{RAD}.
    \item Le code de la station émettrice.
          Comme il n'y a qu'une station réceptrice à présent, la valeur sera toujours \textbf{BEDOUR}.
    \item La date du début de l'enregistrement du fichier.
          Elle respecte le format YYYYMMDD.
    \item Le temps du début de l'enregistrement du fichier, précis à la minute.
          Elle respecte le format HHMM.
    \item Le code de location de la station émettrice.
          Un code de location est composé de deux informations.
          Les deux premiers caractères représentent le code du pays ou se trouve la station (e.g. BE, FR, ...) et les quatre lettres restantes représentent typiquement les quatre premières lettres de la ville où est situé la station (e.g. HUMA pour Humain, UCCL pour Uccle, ...).
    \item L'alias de la station.
          Elle est composée des trois caractères 'SYS', suivie du numéro de l'antenne qu'a capté les données.
          Le numéro de l'antenne est toujours écrit sur trois chiffres (e.g. 001, 002, ...).
\end{enumerate}

Toutes ses valeurs sont séparées par un tiret bas.
Un exemple de nom de fichier est affichée à la figure 7.

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.15]{file_name.png}
        \caption{Exemple de nom de fichier BRAMS.}
    \end{center}
\end{figure}

\newpage

%! develop this part more
\section{Problématique liée à l'étude des données BRAMS}

Afin de pouvoir trouver la trajectoire d'un météore dans l'atmosphère, il est nécessaire de rechercher par quelles stations réceptrices le météore est détecté.
Ceci est une procédure qui prend un temps non négligeable pour les scientifiques du projet.
En effet, toutes les stations de réception ne détectent pas tous les météores.
De plus, certaines données peuvent être corrompues ou encore, non-existantes.\\
\\
De plus, savoir, ou au moins avoir une idée, si un météore détecté par une station réceptrice est le même qu'un météore détecté sur une autre station réceptrice serait une grosse économie de temps.\\
\\
C'est pour cette raison que les membres du projet BRAMS souhaitent automatiser deux procédures.
D'une part, il faut un logiciel capable de vérifier si un fichier contient des données non-corrompues et utilisables.
Dans le cas où les données sont inutilisables, le programme doit pouvoir aider l'utilisateur à retrouver la cause du problème.
D'autre part, il faut un programme qui, sur base d'un écho de météore d'une station de réception, retrouve les échos pouvant venir de ce même météore sur des fichiers d'autres stations de réception.
Ce dernier logiciel doit également donner le plus d'informations possibles pouvant aider à confirmer si un écho correspond à un autre.

\newpage

\section{Méthodologie}

Afin d'arriver à un résultat final de qualité et qui est conforme aux requis des membres du projet BRAMS, il est important d'utiliser une bonne méthodologie.\\
\\
La première chose que j'ai fait est : comprendre quoi exactement le programme devrait faire.
Pour ce faire, plusieurs réunions ont eu place avant la réalisation du travail.
Durant ces réunions, j'ai pu poser mes questions et demander des explications sur les concepts à connaître pour pouvoir réaliser le travail.
Ayant reçu des documents qui expliquent de façon claire et précise le fonctionnement du réseau BRAMS, j'ai pu me préparer avant de m'attaquer à l'analyse et la réalisation du travail.\\
\\
Durant la période d'analyse et de réalisation du TFE, j'ai pu régulièrement demander validation quant à la direction que je prenais pour mon travail.
Je présentais régulièrement mes réalisations aux scientifiques du projet BRAMS afin d'avoir un feedback régulier et de pouvoir perfectionner mon programme un maximum.\\
\\
Dans le but d'être plus efficace lors de l'écriture des fonctionnalités pour le programme, je décrivais avant ce que cette fonctionnalité devait faire.
Ensuite, je la divisais en tâches techniques afin de pouvoir m'organiser plus facilement.
Chaque tâche technique contenait et expliquait les étapes que le programme devrait exécuter pour accomplir cette tâche technique.
Les étapes étaient décrites textuellement, par pseudo-code, par schéma ou encore, par le mélange de deux ou trois des moyens cités.\\
\\
Durant l'entièreté du projet de fin d'études, j'ai tenté de garder un rythme de travail régulier.
Je me suis organisé de telle façon de pouvoir travailler une moyenne de 23 heures par semaine.
Une grande partie de ces heures se sont déroulés lorsque je rentrais de mon stage ou pendant le week-end.\\

\newpage

\section{Technologies utilisées}

\subsection{Python}

Le programme réalisé est entièrement écrit en Python.
Ce choix a été pris premièrement pour les librairies performantes et open-source qu'offre Python.
En effet, des librairies comme numpy, scipy ou encore matplotib ont été très utiles pour arriver à un résultat performant et fonctionnelle.
Ces librairies offrent beaucoup de flexibilité et offrent une haute performance grâce à leur écriture en C, C++ et même en Fortran.\\
\\
Un autre avantage du Python est sa portabilité.
Puisque c'est un langage interprété, largement répandu, quasiment tous les systèmes d'exploitation le supportent.
Ceci a facilité aussi bien la phase de développement que la phase de testing du projet de fin d'études.\\
\\
Un des désavantages souvent évoqués pour Python, est que le langage est lent pour des gros traitement de données.
Cependant, dans le cas de ce travail, ceci ne fut pas un problème et les librairies utilisées étaient largement assez rapide.
Ceci est dû, entre autres, grâce à la nature open-source de ces librairies ainsi que leur âge.
Suite à ces deux facteurs, des milliers de personnes travaillent sur ces librairies depuis plusieurs années dans le but d'optimiser le plus possible ses fonctions et méthodes.

\subsubsection{Librairies Utilisées}

Dans cette section sont listées toutes les librairies Python utilisés pour la réalisation du travail de fin d'études.\\
\\
\textbf{Argparse}\\
Argparse est une librairie Python qui permet de facilement créer une interface ergonomique en ligne de commande.
On spécifie les paramètres nécessaires et optionnels pour le programme qu'on crée, et lorsqu'on lance le programme, Argparse pourra retrouver les paramètres entrés par l'utilisateur.
Il indiquera également une erreur si un paramètre obligatoire manque, ou qu'un type de paramètre n'est pas respecté.
Argparse est une librairie installée par défaut avec Python.\\
\\
\textbf{CSV}\\
La librairie CSV offre la possibilité d'écrire et de lire des fichiers CSV à l'aide d'un programme en Python.\\
\\
\textbf{Datetime}\\
La librairie Datetime offre une suite de fonctions et de classes permettant la manipulation et la conversion de temps et de dates.
Cette librairie fait partie des modules standards de Python et ne doit donc pas être installé.\\
\\
\textbf{Dotenv}\\
La librairie Dotenv permet de lire les fichiers et les variables d'environnement.\\
\\
\textbf{GeoPy}\\
GeoPy est une librairie Python qui facilite la recherche de coordonnées d'adresses, de villes ou encore de lieux connus.
Elle permet également de trouver la distance entre deux lieux en donnant les coordonnées de ces endroits.\\
\\
\textbf{Math}\\
Le module math offre toute une série de fonctions mathématique de base.
Elle est installée par défaut avec Python.\\
\\
\textbf{Matplotlib}\\
La librairie Python Matplotlib permet de générer des graphiques et de les enregistrer en tant qu'image.\\
\\
\textbf{Mysql.connector}\\
Cette librairie permet d'établir une connexion à une base de données MySQL ou MariaDB.
Avec cette connexion, un programme Python peut faire des requêtes à cette base de données.\\
\\
\textbf{NumPy}\\
NumPy est une librairie Python utilisée lorsqu'on travaille avec des listes très larges.
Il contient de nombreuses fonctions pour l'algèbre linéaire, les Transformées de Fourier et les matrices.
Par rapport aux listes classiques de Python, les listes NumPy (aussi appelés des ndarray) sont beaucoup plus rapides.\\
\\
Ceci est dû à trois raisons principales.
La première est que les listes NumPy sont stockés à un endroit continu dans la mémoire RAM\footnote{Random Access Memory}, ce qui permet un accès et une manipulation plus efficace des données.
Ensuite, comme NumPy est une librairie open-source, il est continuellement adapté à des nouvelles architectures de processeurs.
Finalement, une grande partie de la librairie NumPy est écrit dans des langages de bas niveau tels que le C, le C++ ou encore le Fortran.
Ceci résulte à un code beaucoup plus proche du langage machine et qui est donc plus optimisé.\\
\\
\textbf{Os}\\
La librairie os de Python contient une suite de fonctions permettant d'interagir avec le système d'exploitation.
Cette librairie vient par défaut avec une installation de Python, ce qui évite de devoir l'installer lorsque nécessaire.\\
\\
\textbf{SciPy}\\
Scipy est une librairie qui est basé sur la librairie NumPy.
Elle partage donc de nombreuses fonctions et méthodes avec cette dernière et fonctionne également avec des ndarray.
Cependant, cette librairie ajoute des fonctions pour la science des données.
De plus, Scipy optimise des fonctions déjà présentes dans la librairie NumPy.
Ceci permet de construire un programme qui demande moins de ressources machine et qui est donc plus rapide.\\
\\
\textbf{Simplejson}\\
Simplejson est une librairie Python offrant la possibilité de facilement écrire et lire des fichiers JSON\footnote{JavaScript Object Notation}.
Elle vient par défaut avec Python sous le nom 'json'.
Cependant, installer Simplejson séparément ajoute l'avantage d'avoir des mises à jour plus régulières et de disposer des dernières fonctionnalités plus rapidement.\\
\\
\textbf{Tarfile}\\
Le module Python Tarfile permet de lire et écrire des fichiers du format TAR.
Cette librairie est incluse par défaut avec Python et ne doit donc pas être installé séparément.\\
\\
\textbf{Tqdm}\\
Tqdm est une librairie Python permettant d'afficher des barres de chargements en ligne de commande.
Elle permet également de donner une estimation de temps de chargement restant.\\

\subsection{MariaDB}

Afin de sauvegarder les données produites par le programme, une base de données est requise.
Les données seront enregistrées dans la base de données existent du projet BRAMS.
Le type de base de données du projet BRAMS et MariaDB.
% Les données produites seront toutes liées à un fichier, le choix d'une base de données relationnelle est donc appropriée.\\
% \\
% MariaDB est une dérivée de MySQL.
% Elle a l'avantage d'être gratuite et open-source.
% Grâce à une large communauté contribuant au développement continu de MariaDB, elle est souvent plus performante que MySQL.
% De plus, étant open-source, les problèmes sont résolus rapidement par des mises à jour régulières.\\
% \\
% Enfin, le projet BRAMS dispose actuellement déjà d'une base de données MariaDB.
% Elle contient, entre autres, les données de chaque fichier archivé, venant d'une station de réception BRAMS.
% Pour le programme, il suffit donc de rajouter les champs nécessaires à la table contenant les fichiers.
% MariaDB est donc le choix logique.

\newpage

\section{Lecture des Fichiers BRAMS}

Avant de commencer à développer des outils pour la détection des météores ou pour l'analyse des fichiers BRAMS, il a fallu développer un logiciel permettant de lire ces fichiers.
Ce logiciel sera implémenté dans un module Python contenant une classe nommée BramsWavFile.
Ceci veut dire qu'il pourra facilement être utilisé par d'autres fichiers Python et qu'il doit donc être flexible.
Dans cette section, le fonctionnement de ce module est expliqué en détail.

\subsection{Fonctionnement du Module}

Le contenu principal du module est donc la classe BramsWavFile.
Cette classe permet de lire et de récupérer des informations sur les fichiers WAV du réseau BRAMS de manière efficace.
Elle est basée sur un code écrit par Michel Anciaux, membre du projet BRAMS.
Cependant, elle a fortement été retravaillé afin de l'adapter aux besoins du programme et de l'optimiser.
La classe prend six paramètres en entrée :

\begin{itemize}
    \item Le paramètre \textbf{date\_time} indique le temps et la date du fichier recherché.
          Ce paramètre est obligatoire et doit être de type datetime, type qui est défini dans le module datetime.
    \item Le paramètre \textbf{station} indique le code de location de la station recherchée (e.g. BEHUMA, BEHAAC, BEUCCL).
          Les deux premières lettres de ce code représentent le code pays (e.g. BE, FR).
          Typiquement, les quatre lettres suivantes sont les quatre premières lettres de la ville ou se trouve la station.
          Ce paramètre est obligatoire et doit être de type str (chaine de caractères).
    \item Le paramètre \textbf{alias} indique l'antenne, se trouvant à la location spécifiée, dont on veut récupérer un fichier.
          En effet, certaines stations disposent de plusieurs antennes.
          Les antennes sont spécifiées à l'aide de six caractères : les trois premiers contiennent les lettres 'SYS' et les trois suivants contiennent le numéro de l'antenne (e.g. 001, 002, ...).
          La valeur par défaut de ce paramètre est 'SYS001', c'est donc un paramètre optionnel.
          Le type du paramètre est str (chaine de caractères).
    \item Le paramètre \textbf{is\_wav} est un booléen indiquant à la classe si le fichier recherché se trouve dans un fichier de format TAR (dans quel cas la valeur devrait être 'faux') ou pas (dans quel cas la valeur devrait être 'vrai').
          Ce paramètre est optionnel et prend la valeur 'faux' par défaut.
    \item Le paramètre \textbf{parent\_directory} indique le répertoire parent ou il faudra commencer la recherche du fichier demandé.
          C'est un paramètre optionnel de type str (chaine de caractère) qui prend le répertoire de l'archive BRAMS comme valeur par défaut.
    \item Le paramètre \textbf{from\_archive} est un booléen indiquant si le fichier recherché se trouve dans un répertoire respectant la structure de l'archive BRAMS (dans quel cas la valeur est 'vrai') ou non (dans quel cas la valeur est 'faux').
          Elle prend la valeur 'vrai' par défaut et est donc optionnel.
\end{itemize}

Lorsque la classe est initialisée, elle vérifie d'abord si le fichier recherché existe.
Si le paramètre 'from\_archive' contient la valeur 'vrai', la classe rajoute, au chemin spécifié par le paramètre 'parent\_directory', les dossiers nécessaires pour que le chemin respecte la structure de l'archive BRAMS.
Ensuite, le programme essaye de lister les contenus du dossier.
Dans le cas ou le dossier n'est pas trouvé, l'initialisation de la classe est interrompue et l'exception 'DirectoryNotFoundError' est levée.\\
\\
La classe recherche ensuite pour le bon fichier dans le contenu du répertoire en comparant la date et le temps dans le nom du fichier avec la date et le temps reçu comme paramètre.
Quand les fichiers WAV sont contenus dans une archive TAR, l'étape précédente est répétée pour trouver le bon fichier dans l'archive.
Si aucun fichier correspondant à la date et la station reçue en paramètres est trouvé, l'initialisation de la classe est interrompue et l'exception 'BramsError' est levée.
Une fois le bon fichier trouvé, toutes les données brutes sont lues et enregistrées dans un buffer (variable).\\
\\
La prochaine étape est la séparation des différents blocs de données (ou chunk) contenus dans le fichier WAV.
Pour ça, la classe parcourt le buffer contenant les données du fichier WAV.
Il utilise un pointeur de lecture indiquant la position en octets du prochain bloc de données dans le buffer.
Ce pointeur est calculé à partir du champ 'subChunkSize' indiquant la longueur du bloc de données courant.\\
\\
Lorsque le programme retrouve un bloc de données avec un champ ID correspondant à 'fmt ', 'BRA1' ou 'data', il extrait toutes ces données et les place dans un ndarray.
Ceci est fait à l'aide de la fonction 'frombuffer' venant de la librairie NumPy.
Cette fonction offre la possibilité de convertir, de façon très rapide, des données vers un ndarray.
Une des contraintes pour utiliser cette fonction est l'indication du type de données qu'on veut placer dans un ndarray.\\
\\
Les données contenues dans la classe seront la fréquence d'échantillonnage, extrait du bloc de données 'BRA1', et la piste audio du fichier WAV, extrait du bloc de données 'data'.

\subsubsection{La méthode FFT}

La classe BramsWavFile dispose d'une méthode publique.
Cette méthode se nomme 'FFT' et permet, comme son nom l'indique, de récupérer la Transformée de Fourier de l'entièreté de la piste audio du fichier WAV.
Ceci est fait à l'aide de la fonction 'rfft' de la librairie Scipy, multipliée par une fenêtre de Hann.
La fonction 'rfft' existe également dans la librairie NumPy, cependant dans ce cas de figure la librairie SciPy permettait de calculer la Transformée de Fourrier plus rapidement.
Enfin, la fonction FFT retourne la Transformée de Fourier normalisée, son abscisse et sa résolution fréquentielle.\\
\\
Le code de cette méthode peut être visualisé à la figure 8.

\begin{figure}
    \begin{lstlisting}[style=CStyle]
def FFT(self, Isamples, force_new=False):
    if (
        self.fft is not None
        and self.fft_fbin is not None
        and self.fft_freq is not None
        and not force_new
    ):
        return self.fft_freq, self.fft, self.fft_fbin

    # get the length of all the audio samples
    nsamples = Isamples.size

    # create a window funtion
    w = windows.hann(nsamples)
    w_scale = 1 / w.mean()

    # apply that window on all the audio samples
    Isamples = Isamples * w * w_scale

    # get the Fourier Tranform and normalize it
    S = rfft(Isamples) / nsamples
    S[1: -1] *= 2

    self.fft = S
    self.fft_fbin = self.fs / nsamples
    self.fft_freq = rfftfreq(nsamples, 1 / self.fs)

    return self.fft_freq, S, self.fft_fbin
    \end{lstlisting}
    \caption{Code de la méthode qui génère une Transformée de Fourier sur base de données audio.}
\end{figure}

\newpage

\section{Monitoring des Données BRAMS}

Comme indiqué précédemment, les fichiers ne contiennent pas toujours des données utilisables.
Pour des diverses raisons, il peut parfois arriver que le bruit est trop fort pour pouvoir détecter des météores.
Ou encore, lorsque les stations ICOM arrivent en fin de vie, la puissance des données détectées décroît de telle sorte qu'on détecte du bruit seulement.
Bref, de nombreux problèmes peuvent survenir avec les données.
Pour optimiser la détection de météores, les données corrompus doivent être détectés avant celle-ci.
C'est pourquoi, un outil permettant le monitoring des données a été développé.\\
\\
Cet outil se base sur deux éléments dans les données BRAMS indiquant si un fichier est utile ou non.
Le premier est le bruit.
En effet, lorsque le bruit augmente ou diminue beaucoup d'un coup ou graduellement sans revenir à un niveau normal, il est fort probable qu'il y ait un problème avec la station réceptrice ou son environnement.\\
\\
Le deuxième élément permettant de détecter un problème est le signal du calibreur.
Le signal calibreur devrait toujours être présent dans un fichier produit par une station réceptrice.
Typiquement elle devrait se trouver autour de la fréquence 1500 Hz.
Cependant, avec les anciennes stations, elle peut varier jusqu'à 250 Hz dépendant de la chaleur.
Dans le cas où elle n'est pas aux alentours de 1500 Hz, la probabilité qu'il y ait une erreur avec la station est grande.

\subsection{Fonctionnement du Programme}

\begin{figure}
    \begin{lstlisting}[style=CStyle]
def get_psd(f, flow=800, fhigh=900):
    # get fourier tranform from BramsWavFile class
    freq, S, fbin = f.FFT(f.Isamples)
    idx = (freq >= flow) * (freq < fhigh)

    # calculate the total power of the wanted frequencies
    p = (S[idx] * S[idx].conj()).real / 2

    # get a mean normalized to 1Hz
    psd = p.mean() / fbin

    return psd
    \end{lstlisting}
    \caption{Code de la fonction permettant de calculer la dsp.}
\end{figure}

Le programme permet donc de mesurer le niveau du bruit et le signal calibreur d'un ou de plusieurs fichiers WAV du projet BRAMS.
Il fait ceci en calculant la densité spectrale de puissance (dsp) de ceux-ci.
La densité spectrale de puissance montre la distribution des puissances à travers les différentes fréquences contenues dans le signal de base.
Ceci permet de comparer ces différentes valeurs et de remarquer des variations non typiques.\\
\\
Lorsqu'on lance le programme, trois paramètres peuvent être ajoutés :
\begin{enumerate}
    \item Le paramètre \textbf{START DATE} indique la date à partir de laquelle on veut mesurer la dsp des fichiers.
          Par défaut, elle prendra la date d'un jour avant le lancement du programme.
    \item Le paramètre \textbf{END DATE} indique la date avant laquelle on veut mesurer la dsp des fichiers.
          Dans le cas où le paramètre 'START DATE' n'est pas donné, elle prend la valeur de la date de lancement du programme.
    \item Le paramètre \textbf{STATIONS} indique les stations pour lesquelles on veut mesurer la dsp des fichiers.
          Si ce paramètre n'est pas donné, le programme mesurera la dsp des fichiers de toutes les stations.
\end{enumerate}

Le programme calculera donc la dsp des fichiers de tous les fichiers générés entre \textbf{START DATE} et \textbf{END DATE} venant des stations \textbf{STATIONS}.\\
\\
La première va donc, pour chaque fichier demandé, performer une suite d'étapes.
Premièrement, elle va chercher le fichier à l'aide de la classe 'BramsWavFile'.
Si une erreur se produit lors de la recherche du fichier, on considère que le fichier n'existe pas et le programme passe au fichier suivant.
Lorsqu'on a le fichier, on peut calculer la dsp du bruit et du signal calibreur.
La fonction permettant de calculer la dsp, peut être visualisée à la figure 9.\\
\\
Dans le cas du bruit, on prend toujours la moyenne de la dsp entre 800 Hz et 900 Hz.
Entre ces deux fréquences on retrouve normalement uniquement du bruit.
Dans les cas où il se trouverait qu'il y ait un signal autre que le bruit, il ne devrait pas avoir grand impact sur la dsp puisque cette dernière se calcule sur 100 Hz, sur l'entièreté d'un fichier.\\
\\
Pour le signal calibreur, in ne suffit pas de calculer la moyenne de la dsp à 1500 Hz.
En effet, la fréquence du calibreur peut varier jusqu'à 250 Hz, autour de la fréquence de 1500 Hz, d'un fichier à l'autre.
Comme le signal calibreur est le seul signal se trouvant entre 1350 Hz et 1750 Hz, il suffit de rechercher la fréquence, entre ces deux valeurs, avec la valeur de dsp maximale.\\
% \\
% Lorsque les deux valeurs de dsp ont été calculées, on peut maintenant détecter d'éventuels variations atypiques par rapport à d'anciennes valeurs.
% Premièrement, le programme ajuste une droite sur les valeurs de dsp du bruit allant de la date du fichier actuel jusqu'à 
\\
Enfin, le programme enregistre toutes les données de dsp dans la base de données BRAMS existante.
Chaque valeur de dsp est alors lié à son fichier.
Si l'option \textbf{-p} (\textbf{--plot}) a été donné au lancement du programme, le programme génère également un graphique représentant l'évolution de la dsp au cours du temps.

\subsection{Résultats}

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.235]{BEHUMA4_2022-03-01_2022-04-30_calibrator.png}
        \caption{Signal calibreur de la station BEHUMA, antenne 4 entre le 1\textsuperscript{er} mars 2022 et le 30 avril 2022.}
    \end{center}
\end{figure}

Lors des tests, quelques résultats ont déjà montrés des informations intéressantes.
Un bon exemple est l'antenne quatre de la station à Humain entre le 1\textsuperscript{er} mars 2022 et le 30 avril 2022, à la figure 10.
On remarque qu'à partir 8 mars 2022, le signal calibreur diminue fortement d'intensité.
Après une étude en profondeur par les scientifiques du projet BRAMS, ils ont trouvé que ceci était dû à un problème avec l'oscillateur local.
Ce problème causait une translation de 500 Hz vers le bas de tout signal.
Ceci veut dire que tous les fichiers générés alors qu'il y avait ce problème sont inutilisables.\\
\\
Un autre exemple est la station à Haacht entre le 1\textsuperscript{er} juillet 2021 et le 31 août 2021 affichée à la figure 11.
Ici, on constate une diminution graduelle de l'intensité du bruit, jusqu'à ce que le récepteur ne capte plus rien.
Ceci est causé suite au vieillissement du récepteur ICOM.
Cette station a donc dû être remplacée.

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.235]{BEHAAC1_2021-07-01_2021-08-31_noise.png}
        \caption{Intensité du bruit de la station BEHAAC, antenne 1 entre le 1\textsuperscript{er} juillet 2021 et le 31 août 2021.}
    \end{center}
\end{figure}

\newpage

\section{Détection des Météores}

Finalement, on arrive à la détection des météores.
Ce programme effectue deux tâches principales.
La première tâche consiste à, à partir des coordonnées d'un météore donné, détecté sur une station donnée, trouver tous les échos qui viennent potentiellement du même météore.
Ensuite, la deuxième tâche du programme est de donner l'utilisateur le plus d'informations possibles pour confirmer qu'un écho correspond à l'écho de météore reçu en entrée ou non.

\subsection{Analyse}

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.6]{a-Illustration-of-the-operation-principle-of-the-convolution-kernel-convolutional-layer.png}
        \caption{Illustration de la convolution.}
    \end{center}
\end{figure}

C'est ici la première étape qui pose la plus grande difficulté.
En effet, la détection de météores consiste à retrouver des objets d'une forme spécifique dans une image.
Cette image est, dans ce cas si, un spectrogramme calculé à partir d'un fichier WAV venant d'une station de réception BRAMS.
De plus, on retrouve sur ce spectrogramme un nombre d'autres parasites que le programme doit pouvoir différencier d'un vrai météore tel que les échos d'avions qui passent, ou encore le signal direct de l'émetteur.\\
\\
Afin de faciliter la rechercher d'échos de météores dans un spectrogramme, l'amplification de ces échos peut faciliter la tâche.
Un écho de météore est, dans un spectrogramme, caractérisé par un signal qui s'étale sur minimum 10 Hz et qui dur typiquement entre une et trois secondes.
Ceci est possible en performant une convolution sur le spectrogramme.
Une convolution est une opération mathématique qui prend deux fonctions en entrée et qui produit un nouveau signal.
Dans ce cas si, le  signal en entrée sera le spectrogramme, ou une partie du spectrogramme, et le deuxième signal est le filtre.
Une illustration de la convolution peut être trouvée à la figure 12.
Afin d'arriver à un bon résultat, il a fallu tester plusieurs filtres.
Le filtre offrant les meilleurs résultats est illustré à la figure 13.
Elle permet de faire deux choses :

\begin{itemize}
    \item Premièrement, elle amplifie les éléments qui font plus de 10 Hz.
          En effet, pour avoir un résultat d'une valeur maximale il faut que le haut et le bas du filtre soient multipliées par des grandes valeurs.
    \item Deuxièmement, elle permet de diminuer l'intensité des éléments qui ont une longue forme horizontale (typiquement des échos d'avions).
\end{itemize}

Suit alors la suppression du signal direct de l'émetteur.
En effet, pour détecter les échos de météores, le signal direct nous complique la tâche.
Pour l'éliminer, le programme recherche d'abord sa fréquence entre 800 Hz et 1200 Hz, en prenant la valeur maximale sur l'entièreté de la durée du fichier, entre ces deux fréquences.
S'il n'est pas retrouvé, on considère qu'il n'est pas détecté (ce qui est le cas sur certaines stations réceptrices).
Par contre, dans le cas où il est détecté, pour chaque seconde, on remplace la valeur du signal direct par la moyenne des valeurs se trouvant autour de la fréquence du signal direct.\\
\\
Ensuite, il faut trouver une méthode permettant de séparer, dans le spectrogramme, les objets du bruit.
La première méthode testée se basait sur un seuil fixe.
Toutes les valeurs qui se trouvaient en dessous de ce seuil étaient considérées comme du bruit et leur valeur était mise à zéro.
Bien que cette méthode fonctionnait bien sur un fichier spécifique, elle posait problème si on voulait la lancer sur plusieurs fichiers différents.
En effet, comme toutes les stations de réception se trouvent dans des environnements différents et disposent parfois même de matériel différent, différent fichier ont des niveaux de bruits différents.\\
Pour la deuxième méthode, le programme essayait de trouver un seuil qui se base sur la valeur du bruit sur l'entièreté d'un spectrogramme.
Pour ce faire, la méthode divisait le spectrogramme, entre les fréquences de 600 Hz et 1400 Hz, en trente zones.
Elle mesurait ensuite, à l'aide de la variance de chaque zone, laquelle contenait le moins d'objets possibles.
Finalement, la méthode calculait la 95e percentile du bloc contenant le moins d'objet possibles.
Toutes les valeurs du spectrogramme se trouvant en dessous de cette valeur seraient considérés comme du bruit et mises à zéro.
Malgré que cette méthode produisait des résultats marginalement meilleurs que celle à seuil fixe, elle n'était toujours pas parfaite étant donné qu'elle se basait sur le bruit d'une partie du spectrogramme, or le bruit peut varier au cours du temps.\\
Finalement, la méthode qui fonctionnait le mieux calculait la 95e percentile pour chaque colonne du spectrogramme.
Ensuite, elle remplace toutes les valeurs de cette colonne se trouvant en dessous de la 95e percentile avec zéro.
Les résidus de bruits qui ne sont pas encore éliminés sont négligeables puisqu'ils s'étalent sur moins de 10 Hz et ne sont donc pas considérés comme des météores.\\
\\
Il faut maintenant éliminer tous les objets qui ne sont pas des échos de météores, mais qui s'étalent sur plus de 10 Hz.
Ceci n'est pas une tâche facile puisque des parasites peuvent venir se mélanger à des échos de météore formant un objet.
La première chose à faire est : nettoyer le spectrogramme des petits parasites, ou encore de résidus de bruits.
Le programme fait cela en labellisant le spectrogramme et en éliminant tout objet s'étalant sur moins de 10 Hz.
Ensuite, on récupère tous les objets restants.
Pour chacun de ces objets, on vérifie s'il n'est pas composé de plusieurs parasites se superposant sur plus de 10 Hz.
Ceci est fait en allant vérifier sur une longueur d'environ treize secondes autour de l'objet détecté, si on retrouve des parasites qui s'étalent sur la même fréquence que cet objet.
Lorsque c'est le cas, l'objet n'est pas considéré comme un météore et est ignoré.
À partir de ce stade, tous les objets détectés sont considérés comme étant des échos de météores.\\
\\
Pour la deuxième étape, le programme récolte le plus d'informations possibles à propos des échos pouvant potentiellement correspondre à l'écho de météore reçu en entrée.
Parmi ces informations, on retrouve tout d'abord le temps où un écho s'est produit.
Ceci est important pour pouvoir situer l'écho si on veut l'étudier en profondeur.\\
Ensuite, le programme calcule la distance entre la station qui a détecté l'écho reçu en entrée et la station dont un écho pourrait correspondre à celui en entrée.
En effet, un météore n'est pas détecté par toutes les stations, et dans le cas où il est détecté par plusieurs stations, ces stations se trouvent souvent proches les uns des autres.\\
La troisième information donnée indique le nombre d'échos trouvés pour une station, pouvant correspondre à l'écho en entrée.
Dans ce cas, il est important d'en informer l'utilisateur, puisque ces échos viennent chacun d'un météore différent et ne peuvent donc pas tous venir de cet écho reçu en entrée.\\
La dernière information donnée par le programme sont la fréquence minimum et la fréquence maximum des échos détectés.
Ces deux fréquences permettront, ensemble avec le temps où l'écho s'est produit, de faciliter la recherche de cet écho pour l'utilisateur.

\begin{figure}
    \begin{lstlisting}[style=CStyle]
        [[ 0.   0.   0.  50.   0.   0.   0. ]
         [ 0.   0.   0.  50.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [-1.5  0.   0.   0.   0.   0.  -1.5]
         [-1.5  0.   0.   0.   0.   0.  -1.5]
         [-1.5  0.   0.   0.   0.   0.  -1.5]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.   0.   0.   0.   0. ]
         [ 0.   0.   0.  50.   0.   0.   0. ]
         [ 0.   0.   0.  50.   0.   0.   0. ]]
    \end{lstlisting}
    \caption{Filtre utilisé pour amplifier les échos de météores.}
\end{figure}

\subsection{Fonctionnement du Programme}

\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.25]{Screenshot from 2022-05-31 16-44-50.png}
        \caption{Spectrogram originale, sans modifications. Les échos de météores sont entourés en rouge.}
    \end{center}
\end{figure}

Le programme prend en entrée le temps et la date de l'écho du météore recherché ainsi que le code de location de la station qui l'a détecté.
À partir du temps et de la date reçue en entrée, le programme calcule l'intervalle de temps dans laquelle elle doit chercher des échos pour les autres stations réceptrices.
Cet intervalle est toujours de six secondes autour du temps reçu en entrée.
Cette valeur a été choisie puisque toute détection en dehors de ces six secondes a très peu de probabilité de venir du même météore que l'écho en entrée.
Toutes les actions sur le spectrogramme s'appliqueront uniquement à l'intérieur de cet intervalle afin d'optimiser le programme.\\
\\
Le programme va ensuite chercher, pour toutes les stations, les informations des fichiers contenant cet intervalle.
Il fait pour ça une requête à la base de données BRAMS.
Puis, pour chaque station, le programme calcule la distance entre la station et la location où l'écho de météore reçu en entrée a été détecté.\\
\\
\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.22]{Screenshot from 2022-05-31 16-32-43.png}
        \caption{Spectrogramme après l'amplification des échos de météores et la suppression de la majorité du bruit.}
    \end{center}
\end{figure}
Quatrièmement, pour tous les fichiers dont on a récolté des informations, on va rechercher les météores dans l'intervalle calculé précédemment.
Pour cette étape, le programme fait d'abord appelle à la classe BramsWavFile, qui ira chercher le fichier et extraire les données audio.
L'étape suivante consiste à générer le spectrogramme à partir de ces données audio.
Afin de générer ce spectrogramme, il faut faire appelle à la classe Spectrogram.
Ceci est une classe spécialement faite pour ce logiciel, qui permet de créer un spectrogramme et de le modifier à l'aide d'une suite de méthodes.
Lorsqu'on appelle cette classe, il faut passer comme paramètre les données audio.
À partir de ces données, la classe va créer le spectrogramme du fichier avec la fonction "scipy.signal.spectrogram()", un exemple du spectrogramme original peut être visualisé à la figure 14.
La classe gardera une copie originale du spectrogramme et une copie pour les modifications, dont elle supprime, dès l'initialisation, le signal direct de l'émetteur.\\
Suit alors une convolution du spectrogramme avec le filtre permettant d'amplifier les échos de météores, cette convolution est faite à l'aide de la fonction 'scipy.ndimage.convolve()'.
Ensuite, le filtre supprimant toutes les valeurs en dessous de la 95e percentile sera appliquée.
Un spectrogramme à ce stade est illustré à la figure 15, ce spectrogramme est le même que celui à la figure 14.
Afin d'éliminer tous les résidus de bruits, le programme labellise le spectrogramme et supprime tout objet s'étalant sur plus de 6 Hz.
Dans le but de reconnecter les météores qui auraient été divisés en deux parties différentes, on applique un filtre moyenneur sur le spectrogramme.
Puis, le logiciel cherche les coordonnées des échos de météore sur le spectrogramme.
Les météores trouvés sur le spectrogramme de la figure 14 et 15 sont affichées à la figure 16.
En comparant les météores mise en évidence à la figure 14 et les échos trouvés par le programme à la figure 16, on constate que le programme arrive bien à retrouver les échos des météores.
Avec ces coordonnées, on pourra alors retrouver la fréquence maximale et la fréquence minimale de l'écho.\\
\\
\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.22]{Screenshot from 2022-05-31 16-33-53.png}
        \caption{Spectrogramme après l'amplification des échos de météores et la suppression de la majorité du bruit.}
    \end{center}
\end{figure}
Enfin, le programme crée un fichier CSV\footnote{Comma Separated Values} (figure 17) qui contiendra une ligne par écho de météore détecté.
Chaque ligne contiendra :
\begin{enumerate}
    \item Le code de location de la station où est détecté l'écho.
    \item Le numéro de l'antenne qui a détecté l'écho.
    \item La date et le temps de début d'enregistrement du fichier d'où vient l'écho.
    \item Le nombres d'écho comptés dans le même fichier que celui d'où vient l'écho.
    \item Le temps, précis à la microseconde, de détection de l'écho.
    \item La fréquence minimum de l'écho.
    \item La fréquence maximum de l'écho.
    \item La distance entre la station où est détecté l'écho et la station de l'écho reçu en entrée.
\end{enumerate}

De cette façon, les données pourront facilement être lues et réutilisées pour étudier ces météores.

%? maybe change this image ?
\begin{figure}[t]
    \begin{center}
        \includegraphics[scale=0.44]{Screenshot from 2022-05-31 16-35-06.png}
        \caption{Exemple de fichier CSV généré par le programme de détection de météores.}
    \end{center}
\end{figure}

\newpage

\section{Pistes d'Améliorations}

Suite à une réflexion sur les programmes réalisés, j'ai pu trouver quelques pistes d'améliorations qui sont intéressantes pour le futur :
\begin{itemize}
    \item Malgré que l'algorithme permettant de détecter des échos de météore fonctionne assez bien, il y a des cas où il détecte des échos là où il n'y en a pas et inversement.
          En effet, lors de cas extrêmes (échos de météore faibles, superposition de nombreux parasites), le programme a parfois du mal à séparer les échos de météores du reste des objets.
          Peaufiner cet algorithme permettrait d'éviter ces problèmes.
    \item Lors de la détection des échos de météore, l'élimination du signal direct de l'émetteur est également un domaine qui peut être amélioré.
          Actuellement, il est remplacé par la moyenne des valeurs situées autour de la fréquence du signal directe.
          Cependant, ceci n'est pas l'idéal puisqu'on élimine une partie du signal utile avec cette méthode.
          Une meilleure façon de l'éliminer est la reconstruction du signal directe, suivi de la soustraction.
    \item Afin d'améliorer l'expérience utilisateur du programme, on pourrait ajouter ces deux programmes au site web BRAMS.
          Ceci permet d'avoir un programme avec une interface plutôt que d'avoir un programme en ligne de commande.
    \item Bien que ce n'est pas un point important, l'optimisation du programme permettrait d'avoir un temps d'exécution plus court.
          Cela peut être achevé en essayant des librairies alternatives à NumPy et SciPy, ou encore à l'aide du développement de ses propres fonctions et méthodes.
\end{itemize}

\newpage

\section{Conclusion}

Le but du travail était d'automatiser deux procédures du projet BRAMS.
Premièrement elle devait permettre aux scientifiques d'identifier les données corrompues et aider à retrouver la cause de ceux-ci.
Ceci a été accompli à l'aide du logiciel de monitoring qui analyse les fichiers du projet BRAMS.\\
\\
Deuxièmement, le travail devait automatiser la recherche de tous les échos de météores pouvant correspondre à un météore spécifique.
Cette tâche peut maintenant être complétée à l'aide du programme de détection de météore.\\
\\
Ce travail m'a permis d'étendre mes connaissances dans le domaine du traitement du signal en mettant en pratique plusieurs notions théoriques vues durant les cours.
Le mélange de ces connaissances avec des nouvelles notions, que je n'avais pas encore appris, afin d'arriver à un résultat final a été un vrai défi pour moi.\\
\\
Enfin, ce projet m'a permis de contribuer à un projet scientifique de grande échelle.

\newpage

\begin{thebibliography}{100}
    \bibitem{brams_site} \textit{Site internet du projet BRAMS}, consulté en janvier 2022\\\url{https://brams.aeronomie.be/}
    \bibitem{sc.spectrogram} \textit{Documentation de la fonction scipy.signal.spectrogram}, consulté en février 2022\\\url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.spectrogram.html}
    \bibitem{spectro1} \textit{Hands-On Tutorial on Visualizing Spectrograms in Python}, consulté en février 2022\\\url{https://analyticsindiamag.com/hands-on-tutorial-on-visualizing-spectrograms-in-python/}
    \bibitem{spectro2} \textit{Cutting unused frequencies with specgram, matplotib}, consulté en février 2022\\\url{https://stackoverflow.com/questions/19468923/cutting-of-unused-frequencies-in-specgram-matplotlib}
    \bibitem{matplotlib} \textit{Documentation Matplotlib}, consulté en février 2022\\\url{https://matplotlib.org/stable/api/mlab_api.html#matplotlib.mlab.specgram}
    \bibitem{spectro3} \textit{Set spectrogram Parameters}, consulté en février 2022\\\url{https://stackoverflow.com/questions/29321696/what-is-a-spectrogram-and-how-do-i-set-its-parameters}
    \bibitem{convolve} \textit{Documentation de la fonction numpy.convolve}, consulté en mars 2022\\\url{https://numpy.org/doc/stable/reference/generated/numpy.convolve.html}
    \bibitem{convolve2} \textit{How to convolve two 2-dimensional matrices in python with scipy}, consulté en mars 2022\\\url{https://moonbooks.org/Articles/How-to-do-a-simple-2D-convolution-between-a-kernel-and-an-image-in-python-with-scipy-/}
    \bibitem{blocs} \textit{Slice 2D array in smaller 2D arrays}, consulté en mars 2022\\\url{https://stackoverflow.com/questions/16856788/slice-2d-array-into-smaller-2d-arrays}
    \bibitem{conf_factor} \textit{Compute a confidence interval from sample data}, consulté en mars 2022\\\url{https://stackoverflow.com/questions/15033511/compute-a-confidence-interval-from-sample-data}
    \bibitem{wav}\textit{Microsoft WAVE soundfile format}, consulté en mars 2022\\\url{http://soundfile.sapp.org/doc/WaveFormat/}
    \bibitem{mail} \textit{Python - Sending Email using SMTP}, consulté en mars 2022\\\url{https://www.tutorialspoint.com/python/python_sending_email.htm}
    \bibitem{convolve3}\textit{The fastest 2D convolution in the world}, consulté en mars 2022\\\url{https://laurentperrinet.github.io/sciblog/posts/2017-09-20-the-fastest-2d-convolution-in-the-world.html}
    \bibitem{convolve4}\textit{Documentation de la fonction scipy.ndimage.convolve}, consulté en mars 2022\\\url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.convolve.html}
    \bibitem{psd}\textit{Power Spectral Density - an overview}, consulté en avril 2022\\\url{https://www.sciencedirect.com/topics/computer-science/power-spectral-density}
    \bibitem{psd2}\textit{What is a Power Spectral Density}, consulté en avril 2022\\\url{https://community.sw.siemens.com/s/article/what-is-a-power-spectral-density-psd}
    \bibitem{datetime}\textit{How to add time onto a datetime object in Python}, consulté en avril 2022\\\url{https://www.adamsmith.haus/python/answers/how-to-add-time-onto-a-datetime-object-in-python}
    \bibitem{fft1}\textit{Fourier Transforms With scipy.fft: Python Signal Processing}, consulté en avril 2022\\\url{https://realpython.com/python-scipy-fft/#why-would-you-need-the-fourier-transform}
    \bibitem{fft2}\textit{Documentation de la fonction scipy.fft.rfft}, consulté en avril 2022\\\url{https://docs.scipy.org/doc/scipy/reference/generated/scipy.fft.rfft.html}
    \bibitem{csv}\textit{Reading and Writing CSV Files in Python - Real Python}, consulté en mai 2022\\\url{https://realpython.com/python-csv/}
    \bibitem{tqdm}\textit{A Fast, Extensible Progress Bar for Python and CLI - TQDM}, consulté en mai 2022\\\url{https://github.com/tqdm/tqdm}
    \bibitem{tarfile}\textit{Documentation du module tarfile}, consulté en mai 2022\\\url{https://docs.python.org/3/library/tarfile.html}
    \bibitem{json}\textit{Documentation de la librairie simplejson}, consulté en mai 2022\\\url{https://pypi.org/project/simplejson/}
    \bibitem{cmd_args} \textit{Python Command Line Arguments}, consulté en mai 2022\\\url{https://realpython.com/python-command-line-arguments/}
    \bibitem{argparse}\textit{Documentation du module argparse}, consulté en mai 2022\\\url{https://docs.python.org/3/library/argparse.html}
    \bibitem{img}\textit{Artificial neural network for bubbles pattern recognition on the images - Scientific Figure on ResearchGate}, consulté en mai 2022\\\url{https://www.researchgate.net/figure/a-Illustration-of-the-operation-principle-of-the-convolution-kernel-convolutional-layer_fig2_309487032}
\end{thebibliography}

\newpage

\section{Annexes}



\end{document}